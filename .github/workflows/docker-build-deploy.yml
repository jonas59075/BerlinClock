name: Docker Build & Deploy

# Baut die Docker-Images nach erfolgreichen Tests, pusht sie in die Registry
# und aktualisiert die produktive Umgebung auf einem Windows-Self-Hosted-Runner.
on:
  push:
    branches: ["main"]
  workflow_dispatch:

concurrency:
  group: docker-build-deploy
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_BACKEND: ghcr.io/${{ github.repository | toLower }}/backend
  IMAGE_FRONTEND: ghcr.io/${{ github.repository | toLower }}/frontend

jobs:
  build:
    name: Images bauen & veröffentlichen
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
    steps:
      - name: Repository auschecken
        uses: actions/checkout@v4

      # Buildx ermöglicht parallele und spätere Multi-Arch-Builds.
      - name: Docker Buildx aktivieren
        uses: docker/setup-buildx-action@v3

      # Authentifizierung am GitHub Container Registry via Token/ID Token.
      - name: Bei GHCR anmelden
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}

      # Backend-Image bauen und pushen.
      - name: Backend-Image bauen und pushen
        uses: docker/build-push-action@v6
        with:
          context: backend
          file: backend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_BACKEND }}:latest
            ${{ env.IMAGE_BACKEND }}:${{ github.sha }}

      # Frontend-Image bauen und pushen.
      - name: Frontend-Image bauen und pushen
        uses: docker/build-push-action@v6
        with:
          context: frontend
          file: frontend/Dockerfile
          push: true
          tags: |
            ${{ env.IMAGE_FRONTEND }}:latest
            ${{ env.IMAGE_FRONTEND }}:${{ github.sha }}

  deploy:
    name: Deployment auf Self-Hosted-Runner (Windows)
    needs: build
    runs-on:
      - self-hosted
      - Windows
      - X64
    permissions:
      contents: read
      packages: read
    environment:
      name: production
      url: http://localhost
    steps:
      # Minimaler Checkout, falls Compose-Datei oder Skripte benötigt werden.
      - name: Repository auschecken
        uses: actions/checkout@v4

      # Docker-Login mit bereitgestelltem Token (GHCR_PAT empfohlen).
      - name: Bei GHCR anmelden
        shell: pwsh
        run: echo "${{ secrets.GHCR_PAT || secrets.GITHUB_TOKEN }}" | docker login $env:REGISTRY -u "${{ github.actor }}" --password-stdin

      # Sicherstellen, dass die Compose-Datei vorhanden ist (z. B. unter C:\\docker\\berlinclock).
      - name: Compose-Datei validieren
        shell: pwsh
        run: |
          $composePath = "C:\\docker\\berlinclock\\docker-compose.yml"
          if (-not (Test-Path $composePath)) {
            Write-Error "Compose-Datei fehlt am erwarteten Ort: $composePath"
          }

      # Container aktualisieren: Pull + Hochfahren, damit neue Images sofort aktiv werden.
      - name: Container aktualisieren
        shell: pwsh
        run: |
          $composePath = "C:\\docker\\berlinclock\\docker-compose.yml"
          docker compose -f $composePath pull
          docker compose -f $composePath up -d

      # Aufräumen verhindert unnötigen Plattenverbrauch auf dem Runner.
      - name: Ungenutzte Images bereinigen
        shell: pwsh
        run: docker image prune -f
