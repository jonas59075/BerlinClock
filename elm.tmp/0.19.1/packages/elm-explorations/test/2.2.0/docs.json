[{"name":"Expect","comment":" A library to create `Expectation`s, which describe a claim to be tested.\n\n\n## Quick Reference\n\n  - [`equal`](#equal) `(arg2 == arg1)`\n  - [`notEqual`](#notEqual) `(arg2 /= arg1)`\n  - [`lessThan`](#lessThan) `(arg2 < arg1)`\n  - [`atMost`](#atMost) `(arg2 <= arg1)`\n  - [`greaterThan`](#greaterThan) `(arg2 > arg1)`\n  - [`atLeast`](#atLeast) `(arg2 >= arg1)`\n  - [Floating Point Comparisons](#floating-point-comparisons)\n\n\n## Basic Expectations\n\n@docs Expectation, equal, notEqual, all\n\n\n## Numeric Comparisons\n\n@docs lessThan, atMost, greaterThan, atLeast\n\n\n## Floating Point Comparisons\n\nThese functions allow you to compare `Float` values up to a specified rounding error, which may be relative, absolute,\nor both. For an in-depth look, see our [Guide to Floating Point Comparison](#guide-to-floating-point-comparison).\n\n@docs FloatingPointTolerance, within, notWithin\n\n\n## Collections\n\n@docs ok, err, equalLists, equalDicts, equalSets\n\n\n## Customizing\n\nThese functions will let you build your own expectations.\n\n@docs pass, fail, onFail\n\n\n## Guide to Floating Point Comparison\n\nIn general, if you are multiplying, you want relative tolerance, and if you're adding,\nyou want absolute tolerance. If you are doing both, you want both kinds of tolerance,\nor to split the calculation into smaller parts for testing.\n\n\n### Absolute Tolerance\n\nLet's say we want to figure out if our estimation of pi is precise enough.\n\nIs `3.14` within `0.01` of `pi`? Yes, because `3.13 < pi < 3.15`.\n\n    test \"3.14 approximates pi with absolute precision\" <|\n        \\_ ->\n            3.14 |> Expect.within (Absolute 0.01) pi\n\n\n### Relative Tolerance\n\nWhat if we also want to know if our circle circumference estimation is close enough?\n\nLet's say our circle has a radius of `r` meters. The formula for circle circumference is `C=2*r*pi`.\nTo make the calculations a bit easier ([ahem](https://tauday.com/tau-manifesto)), we'll look at half the circumference; `C/2=r*pi`.\nIs `r * 3.14` within `0.01` of `r * pi`?\nThat depends, what does `r` equal? If `r` is `0.01`mm, or `0.00001` meters, we're comparing\n`0.00001 * 3.14 - 0.01 < r * pi < 0.00001 * 3.14 + 0.01` or `-0.0099686 < 0.0000314159 < 0.0100314`.\nThat's a huge tolerance! A circumference that is _a thousand times longer_ than we expected would pass that test!\n\nOn the other hand, if `r` is very large, we're going to need many more digits of pi.\nFor an absolute tolerance of `0.01` and a pi estimation of `3.14`, this expectation only passes if `r < 2*pi`.\n\nIf we use a relative tolerance of `0.01` instead, the circle area comparison becomes much better. Is `r * 3.14` within\n`1%` of `r * pi`? Yes! In fact, three digits of pi approximation is always good enough for a 0.1% relative tolerance,\nas long as `r` isn't [too close to zero](https://en.wikipedia.org/wiki/Denormal_number).\n\n    fuzz\n        (floatRange 0.000001 100000)\n        \"Circle half-circumference with relative tolerance\"\n        (\\r -> r * 3.14 |> Expect.within (Relative 0.001) (r * pi))\n\n\n### Trouble with Numbers Near Zero\n\nIf you are adding things near zero, you probably want absolute tolerance. If you're comparing values between `-1` and `1`, you should consider using absolute tolerance.\n\nFor example: Is `1 + 2 - 3` within `1%` of `0`? Well, if `1`, `2` and `3` have any amount of rounding error, you might not get exactly zero. What is `1%` above and below `0`? Zero. We just lost all tolerance. Even if we hard-code the numbers, we might not get exactly zero; `0.1 + 0.2` rounds to a value just above `0.3`, since computers, counting in binary, cannot write down any of those three numbers using a finite number of digits, just like we cannot write `0.333...` exactly in base 10.\n\nAnother example is comparing values that are on either side of zero. `0.0001` is more than `100%` away from `-0.0001`. In fact, `infinity` is closer to `0.0001` than `0.0001` is to `-0.0001`, if you are using a relative tolerance. Twice as close, actually. So even though both `0.0001` and `-0.0001` could be considered very close to zero, they are very far apart relative to each other. The same argument applies for any number of zeroes.\n\n","unions":[{"name":"FloatingPointTolerance","comment":" A type to describe how close a floating point number must be to the expected value for the test to pass. This may be\nspecified as absolute or relative.\n\n`AbsoluteOrRelative` tolerance uses a logical OR between the absolute (specified first) and relative tolerance. If you\nwant a logical AND, use [`Expect.all`](#all).\n\n","args":[],"cases":[["Absolute",["Basics.Float"]],["Relative",["Basics.Float"]],["AbsoluteOrRelative",["Basics.Float","Basics.Float"]]]}],"aliases":[{"name":"Expectation","comment":" The result of a single test run: either a [`pass`](#pass) or a\n[`fail`](#fail).\n","args":[],"type":"Test.Expectation.Expectation"}],"values":[{"name":"all","comment":" Passes if each of the given functions passes when applied to the subject.\n\nPassing an empty list is assumed to be a mistake, so `Expect.all []`\nwill always return a failed expectation no matter what else it is passed.\n\n    Expect.all\n        [ Expect.greaterThan -2\n        , Expect.lessThan 5\n        ]\n        (List.length [])\n    -- Passes because (0 > -2) is True and (0 < 5) is also True\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which:\n\n    -- Fails because (0 < -10) is False\n    List.length []\n        |> Expect.all\n            [ Expect.greaterThan -2\n            , Expect.lessThan -10\n            , Expect.equal 0\n            ]\n    {-\n    0\n    ╷\n    │ Expect.lessThan\n    ╵\n    -10\n    -}\n\n","type":"List.List (subject -> Expect.Expectation) -> subject -> Expect.Expectation"},{"name":"atLeast","comment":" Passes if the second argument is greater than or equal to the first.\n\n    Expect.atLeast -2 (List.length [])\n\n    -- Passes because (0 >= -2) is True\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which:\n\n    -- Fails because (0 >= 3) is False\n    List.length []\n        |> Expect.atLeast 3\n\n    {-\n\n    0\n    ╷\n    │ Expect.atLeast\n    ╵\n    3\n\n    -}\n\n","type":"comparable -> comparable -> Expect.Expectation"},{"name":"atMost","comment":" Passes if the second argument is less than or equal to the first.\n\n    Expect.atMost 1 (List.length [])\n\n    -- Passes because (0 <= 1) is True\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which:\n\n    -- Fails because (0 <= -3) is False\n    List.length []\n        |> Expect.atMost -3\n\n    {-\n\n    0\n    ╷\n    │ Expect.atMost\n    ╵\n    -3\n\n    -}\n\n","type":"comparable -> comparable -> Expect.Expectation"},{"name":"equal","comment":" Passes if the arguments are equal.\n\n    Expect.equal 0 (List.length [])\n\n    -- Passes because (0 == 0) is True\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which:\n\n    -- Fails because the expected value didn't split the space in \"Betty Botter\"\n    String.split \" \" \"Betty Botter bought some butter\"\n        |> Expect.equal [ \"Betty Botter\", \"bought\", \"some\", \"butter\" ]\n\n    {-\n\n    [ \"Betty\", \"Botter\", \"bought\", \"some\", \"butter\" ]\n    ╷\n    │ Expect.equal\n    ╵\n    [ \"Betty Botter\", \"bought\", \"some\", \"butter\" ]\n\n    -}\n\nDo not equate `Float` values; use [`within`](#within) instead.\n\n","type":"a -> a -> Expect.Expectation"},{"name":"equalDicts","comment":" Passes if the arguments are equal dicts.\n\n    -- Passes\n    Dict.fromList [ ( 1, \"one\" ), ( 2, \"two\" ) ]\n        |> Expect.equalDicts (Dict.fromList [ ( 1, \"one\" ), ( 2, \"two\" ) ])\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which, and reports which keys were missing from\nor added to each dict:\n\n    -- Fails\n    (Dict.fromList [ ( 1, \"one\" ), ( 2, \"too\" ) ])\n        |> Expect.equalDicts (Dict.fromList [ ( 1, \"one\" ), ( 2, \"two\" ), ( 3, \"three\" ) ])\n\n    {-\n\n    Dict.fromList [(1,\"one\"),(2,\"too\")]\n    diff: -[ (2,\"two\"), (3,\"three\") ] +[ (2,\"too\") ]\n    ╷\n    │ Expect.equalDicts\n    ╵\n    diff: +[ (2,\"two\"), (3,\"three\") ] -[ (2,\"too\") ]\n    Dict.fromList [(1,\"one\"),(2,\"two\"),(3,\"three\")]\n\n    -}\n\n","type":"Dict.Dict comparable a -> Dict.Dict comparable a -> Expect.Expectation"},{"name":"equalLists","comment":" Passes if the arguments are equal lists.\n\n    -- Passes\n    [ 1, 2, 3 ]\n        |> Expect.equalLists [ 1, 2, 3 ]\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which, and reports which index the lists first\ndiffered at or which list was longer:\n\n    -- Fails\n    [ 1, 2, 4, 6 ]\n        |> Expect.equalLists [ 1, 2, 5 ]\n\n    {-\n\n    [1,2,4,6]\n    first diff at index index 2: +`4`, -`5`\n    ╷\n    │ Expect.equalLists\n    ╵\n    first diff at index index 2: +`5`, -`4`\n    [1,2,5]\n\n    -}\n\n","type":"List.List a -> List.List a -> Expect.Expectation"},{"name":"equalSets","comment":" Passes if the arguments are equal sets.\n\n    -- Passes\n    Set.fromList [ 1, 2 ]\n        |> Expect.equalSets (Set.fromList [ 1, 2 ])\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which, and reports which keys were missing from\nor added to each set:\n\n    -- Fails\n    (Set.fromList [ 1, 2, 4, 6 ])\n        |> Expect.equalSets (Set.fromList [ 1, 2, 5 ])\n\n    {-\n\n    Set.fromList [1,2,4,6]\n    diff: -[ 5 ] +[ 4, 6 ]\n    ╷\n    │ Expect.equalSets\n    ╵\n    diff: +[ 5 ] -[ 4, 6 ]\n    Set.fromList [1,2,5]\n\n    -}\n\n","type":"Set.Set comparable -> Set.Set comparable -> Expect.Expectation"},{"name":"err","comment":" Passes if the\n[`Result`](http://package.elm-lang.org/packages/elm-lang/core/latest/Result) is\nan `Err` rather than `Ok`. This is useful for tests where you expect to get an\nerror but you don't care what the actual error is.\n\n_(Tip: If your function returns a `Maybe` instead, consider `Expect.equal Nothing`.)_\n\n    -- Passes\n    String.toInt \"not an int\"\n        |> Result.fromMaybe \"not an int\"\n        |> Expect.err\n\nTest failures will be printed with the unexpected `Ok` value contrasting with\nany `Err`.\n\n    -- Fails\n    String.toInt \"20\"\n        |> Result.fromMaybe \"not an int\"\n        |> Expect.err\n\n    {-\n\n    Ok 20\n    ╷\n    │ Expect.err\n    ╵\n    Err _\n\n    -}\n\n","type":"Result.Result a b -> Expect.Expectation"},{"name":"fail","comment":" Fails with the given message.\n\n    import Json.Decode exposing (decodeString, int)\n    import Test exposing (test)\n    import Expect\n\n\n    test \"Json.Decode.int can decode the number 42.\" <|\n        \\_ ->\n            case decodeString int \"42\" of\n                Ok _ ->\n                    Expect.pass\n\n                Err err ->\n                    Expect.fail err\n\n","type":"String.String -> Expect.Expectation"},{"name":"greaterThan","comment":" Passes if the second argument is greater than the first.\n\n    Expect.greaterThan -2 List.length []\n\n    -- Passes because (0 > -2) is True\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which:\n\n    -- Fails because (0 > 1) is False\n    List.length []\n        |> Expect.greaterThan 1\n\n    {-\n\n    0\n    ╷\n    │ Expect.greaterThan\n    ╵\n    1\n\n    -}\n\n","type":"comparable -> comparable -> Expect.Expectation"},{"name":"lessThan","comment":" Passes if the second argument is less than the first.\n\n    Expect.lessThan 1 (List.length [])\n\n    -- Passes because (0 < 1) is True\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which:\n\n    -- Fails because (0 < -1) is False\n    List.length []\n        |> Expect.lessThan -1\n\n\n    {-\n\n    0\n    ╷\n    │ Expect.lessThan\n    ╵\n    -1\n\n    -}\n\nDo not equate `Float` values; use [`notWithin`](#notWithin) instead.\n\n","type":"comparable -> comparable -> Expect.Expectation"},{"name":"notEqual","comment":" Passes if the arguments are not equal.\n\n    -- Passes because (11 /= 100) is True\n    90 + 10\n        |> Expect.notEqual 11\n\n\n    -- Fails because (100 /= 100) is False\n    90 + 10\n        |> Expect.notEqual 100\n\n    {-\n\n    100\n    ╷\n    │ Expect.notEqual\n    ╵\n    100\n\n    -}\n\n","type":"a -> a -> Expect.Expectation"},{"name":"notWithin","comment":" Passes if (and only if) a call to `within` with the same arguments would have failed.\n","type":"Expect.FloatingPointTolerance -> Basics.Float -> Basics.Float -> Expect.Expectation"},{"name":"ok","comment":" Passes if the\n[`Result`](https://package.elm-lang.org/packages/lang/core/latest/Result) is\nan `Ok` rather than `Err`. This is useful for tests where you expect not to see\nan error, but you don't care what the actual result is.\n\n_(Tip: If your function returns a `Maybe` instead, consider `Expect.notEqual Nothing`.)_\n\n    -- Passes\n    String.toInt \"20\"\n        |> Result.fromMaybe \"not an int\"\n        |> Expect.ok\n\nTest failures will be printed with the unexpected `Err` value contrasting with\nany `Ok`.\n\n    -- Fails\n    String.toInt \"not an int\"\n        |> Result.fromMaybe \"not an int\"\n        |> Expect.ok\n\n    {-\n\n    Err \"not an int\"\n    ╷\n    │ Expect.ok\n    ╵\n    Ok _\n\n    -}\n\n","type":"Result.Result a b -> Expect.Expectation"},{"name":"onFail","comment":" If the given expectation fails, replace its failure message with a custom one.\n\n    \"something\"\n        |> Expect.equal \"something else\"\n        |> Expect.onFail \"thought those two strings would be the same\"\n\n","type":"String.String -> Expect.Expectation -> Expect.Expectation"},{"name":"pass","comment":" Always passes.\n\n    import Json.Decode exposing (decodeString, int)\n    import Test exposing (test)\n    import Expect\n\n\n    test \"Json.Decode.int can decode the number 42.\" <|\n        \\_ ->\n            case decodeString int \"42\" of\n                Ok _ ->\n                    Expect.pass\n\n                Err err ->\n                    Expect.fail err\n\n","type":"Expect.Expectation"},{"name":"within","comment":" Passes if the second and third arguments are equal within a tolerance\nspecified by the first argument. This is intended to avoid failing because of\nminor inaccuracies introduced by floating point arithmetic.\n\n    -- Fails because 0.1 + 0.2 == 0.30000000000000004 (0.1 is non-terminating in base 2)\n    0.1 + 0.2 |> Expect.equal 0.3\n\n    -- So instead write this test, which passes\n    0.1 + 0.2 |> Expect.within (Absolute 0.000000001) 0.3\n\nFailures resemble code written in pipeline style, so you can tell\nwhich argument is which:\n\n    -- Fails because 3.14 is not close enough to pi\n    3.14 |> Expect.within (Absolute 0.0001) pi\n\n    {-\n\n    3.14\n    ╷\n    │ Expect.within Absolute 0.0001\n    ╵\n    3.141592653589793\n\n    -}\n\n","type":"Expect.FloatingPointTolerance -> Basics.Float -> Basics.Float -> Expect.Expectation"}],"binops":[]},{"name":"Fuzz","comment":" This is a library of _fuzzers_ you can use to supply values to your fuzz\ntests. You can typically pick out which ones you need according to their types.\n\nA `Fuzzer a` knows how to create values of type `a`. It can create them randomly,\nso that your test's expectations are run against many values. Fuzzers will often\ngenerate edge cases likely to find bugs. If the fuzzer can make your test fail,\nthe test runner also knows how to \"simplify\" that failing input into more minimal\nexamples, some of which might also cause the tests to fail. In this way, fuzzers\ncan usually find the simplest input that reproduces a bug.\n\n\n## Fuzzers\n\n@docs Fuzzer, examples, labelExamples\n\n\n## Number fuzzers\n\n@docs int, intRange, uniformInt, intAtLeast, intAtMost\n@docs float, niceFloat, percentage, floatRange, floatAtLeast, floatAtMost\n\n\n## String-related fuzzers\n\n@docs char, asciiChar\n@docs string, stringOfLength, stringOfLengthBetween, asciiString, asciiStringOfLength, asciiStringOfLengthBetween\n\n\n## Collection fuzzers\n\n@docs pair, triple\n@docs list, listOfLength, listOfLengthBetween, shuffledList\n@docs array, maybe, result\n\n\n## Other fuzzers\n\n@docs bool, unit, order, weightedBool\n\n\n## Choosing fuzzers\n\n@docs oneOf, oneOfValues, frequency, frequencyValues\n\n\n## Working with Fuzzers\n\n@docs constant, invalid, filter, filterMap\n@docs map, map2, map3, map4, map5, map6, map7, map8, andMap\n@docs andThen, lazy, sequence, traverse\n\n\n## Misc helpers\n\n@docs fromGenerator\n\n","unions":[],"aliases":[{"name":"Fuzzer","comment":" The representation of fuzzers is opaque. Conceptually, a `Fuzzer a` consists\nof a way to randomly generate values of type `a` in a way allowing the test runner\nto simplify those values.\n","args":["a"],"type":"Fuzz.Internal.Fuzzer a"}],"values":[{"name":"andMap","comment":" Map over many fuzzers. This can act as `mapN` for `N > 8`.\nThe argument order is meant to accommodate chaining:\n\n    Fuzz.constant fn\n        |> Fuzz.andMap fuzzerA\n        |> Fuzz.andMap fuzzerB\n        |> Fuzz.andMap fuzzerC\n\n","type":"Fuzz.Fuzzer a -> Fuzz.Fuzzer (a -> b) -> Fuzz.Fuzzer b"},{"name":"andThen","comment":" Use a generated value to decide what fuzzer to use next.\n\nFor example, let's say you want to generate a list of given length.\nOne (not ideal) possible way to do that is first choosing how many elements\nwill there be (generating a number), `andThen` generating a list with that many\nitems:\n\n    Fuzz.intRange 1 10\n        |> Fuzz.andThen\n            (\\length ->\n                let\n                    go : Int -> List a -> Fuzzer (List a)\n                    go left acc =\n                        if left <= 0 then\n                            Fuzz.constant (List.reverse acc)\n\n                        else\n                            itemFuzzer\n                                |> Fuzz.andThen (\\item -> go (length - 1) (item :: acc))\n                in\n                go length []\n            )\n\nThis will work! Different fuzzers will have different PRNG usage patterns\nthough and will shrink with varying success. The currently best known way to\nfuzz a list of items is based on a \"flip a coin, `andThen` generate a value and\nrepeat or end\" approach, and is implemented in the [`Fuzz.list`](#list) helpers\nin this module. Use them instead of rolling your own list generator!\n\nThink of `andThen` as a generalization of [`Fuzz.map`](#map). Inside\n[`Fuzz.map`](#map) you don't have the option to fuzz another value based on\nwhat you already have; inside `andThen` you do.\n\n","type":"(a -> Fuzz.Fuzzer b) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b"},{"name":"array","comment":" Given a fuzzer of a type, create a fuzzer of an array of that type.\nGenerates random arrays of varying length, favoring shorter arrays.\n","type":"Fuzz.Fuzzer a -> Fuzz.Fuzzer (Array.Array a)"},{"name":"asciiChar","comment":" A fuzzer for simple ASCII char values (range 32..126).\nSkips control characters and the extended character set.\n\nFor more serious char fuzzing look at [`Fuzz.char`](#char) which generates the\nwhole Unicode range.\n\n","type":"Fuzz.Fuzzer Char.Char"},{"name":"asciiString","comment":" Generates random ASCII strings of up to 10 characters.\n","type":"Fuzz.Fuzzer String.String"},{"name":"asciiStringOfLength","comment":" Generates random ASCII strings of a given length.\n","type":"Basics.Int -> Fuzz.Fuzzer String.String"},{"name":"asciiStringOfLengthBetween","comment":" Generates random ASCII strings of length between the given limits.\n","type":"Basics.Int -> Basics.Int -> Fuzz.Fuzzer String.String"},{"name":"bool","comment":" A fuzzer for boolean values. It's useful when building up fuzzers of complex\ntypes that contain a boolean somewhere.\n\nWe recommend against writing tests fuzzing over booleans. Write a unit test for\nthe true and false cases explicitly.\n\nSimplifies in order `False < True`.\n\n","type":"Fuzz.Fuzzer Basics.Bool"},{"name":"char","comment":" A fuzzer for arbitrary Unicode char values.\n\nAvoids surrogate pairs or their components (`0xD800..0xDFFF`).\n\nWill prefer ASCII characters, whitespace, and some examples known to cause\ntrouble, like combining diacritics marks and emojis.\n\n","type":"Fuzz.Fuzzer Char.Char"},{"name":"constant","comment":" Create a fuzzer that only and always returns the value provided, and performs\nno simplifying. This is hardly random, and so this function is best used as a\nhelper when creating more complicated fuzzers.\n","type":"a -> Fuzz.Fuzzer a"},{"name":"examples","comment":" Generate a few example values from the fuzzer.\n\nUseful in REPL:\n\n    > import Fuzz\n    > Fuzz.examples 20 (Fuzz.intRange 20 50)\n    [42,45,32,26,33,29,41,45,23,45,34,23,22,42,29,27,41,43,30,50]\n        : List Int\n\nUses the first argument as the seed as well as the count of examples to generate.\n\nWill return an empty list in case of rejection.\n\n","type":"Basics.Int -> Fuzz.Fuzzer a -> List.List a"},{"name":"filter","comment":" A fuzzer that only lets through values satisfying the given predicate\nfunction.\n\nWarning: By using `Fuzz.filter` you can get exceptionally unlucky and get 15\nrejections in a row, in which case the test will fluke out and fail!\n\nIt's always preferable to get to your wanted values using [`Fuzz.map`](#map),\nas you don't run the risk of rejecting too may values and slowing down your\ntests, for example using `Fuzz.intRange 0 5 |> Fuzz.map (\\x -> x * 2)` instead\nof `Fuzz.intRange 0 9 |> Fuzz.filter (\\x -> modBy 2 x == 0)`.\n\nIf you want to generate indefinitely until you find a satisfactory value (with\na risk of infinite loop depending on the predicate), you can use this pattern:\n\n    goodItemFuzzer =\n        itemFuzzer\n            |> Fuzz.andThen\n                (\\item ->\n                    if isGood item then\n                        Fuzz.constant item\n\n                    else\n                        goodItemFuzzer\n                )\n\n","type":"(a -> Basics.Bool) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer a"},{"name":"filterMap","comment":" A fuzzer that applies a function returning a Maybe on a given fuzzer and\noutput values, as List.filterMap does.\n\nExample usage:\n\n    type UnicodeNonLetter\n        = UnicodeNonLetter Char\n\n    fromChar : Char -> Maybe UnicodeNonLetter\n    fromChar c =\n        if (c |> Unicode.isLower |> not) && (c |> Unicode.isUpper |> not) then\n            UnicodeNonLetter |> Just\n\n        else\n            Nothing\n\n    fuzz : Fuzzer UnicodeNonLetter\n    fuzz =\n        Fuzz.char |> Fuzz.filterMap fromChar\n\nWarning: By using `Fuzz.filterMap` you can get exceptionally unlucky and get 15\nrejections in a row, in which case the test will fluke out and fail!\n\nIt's always preferable to get to your wanted values using [`Fuzz.map`](#map),\nas you don't run the risk of rejecting too may values and slowing down your\ntests, for example using `Fuzz.intRange 0 5 |> Fuzz.map (\\x -> x * 2)` instead\nof `Fuzz.intRange 0 9 |> Fuzz.filterMap (\\x -> if modBy 2 x == 0 then Just x else Nothing)`.\n\nIf you want to generate indefinitely until you find a satisfactory value (with\na risk of infinite loop depending on the predicate), you can use this pattern:\n\n    goodItemFuzzer =\n        itemFuzzer\n            |> Fuzz.andThen\n                (\\item ->\n                    case f item of\n                        Just b ->\n                            Fuzz.constant b\n\n                        Nothing ->\n                            goodItemFuzzer\n                )\n\n","type":"(a -> Maybe.Maybe b) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b"},{"name":"float","comment":" A fuzzer for float values.\n\nWill prefer integer values, nice fractions and positive numbers over the rest.\n\nWill occasionally try infinities and NaN. If you don't want to generate these,\nuse [`Fuzz.niceFloat`](#niceFloat).\n\n","type":"Fuzz.Fuzzer Basics.Float"},{"name":"floatAtLeast","comment":" Fuzzer generating floats in range `n..Infinity`.\n\nThe positive part of the range will shrink nicely, the negative part will shrink uniformly.\n\nThe fuzzer will occasionally try the minimum, 0 (if in range) and Infinity.\n\n","type":"Basics.Float -> Fuzz.Fuzzer Basics.Float"},{"name":"floatAtMost","comment":" Fuzzer generating floats in range `-Infinity..n`.\n\nThe negative part of the range will shrink nicely, the positive part will shrink uniformly.\n\nThe fuzzer will occasionally try the maximum, 0 (if in range) and -Infinity.\n\n","type":"Basics.Float -> Fuzz.Fuzzer Basics.Float"},{"name":"floatRange","comment":" A fuzzer for float values within between a given minimum and maximum (inclusive).\n\nShrunken values will also be within the range.\n\n","type":"Basics.Float -> Basics.Float -> Fuzz.Fuzzer Basics.Float"},{"name":"frequency","comment":" Create a new `Fuzzer` by providing a list of probabilistic weights to use\nwith other fuzzers.\nFor example, to create a `Fuzzer` that has a 1/4 chance of generating an int\nbetween -1 and -100, and a 3/4 chance of generating one between 1 and 100,\nyou could do this:\n\n    Fuzz.frequency\n        [ ( 1, Fuzz.intRange -100 -1 )\n        , ( 3, Fuzz.intRange 1 100 )\n        ]\n\nThis fuzzer will simplify towards the fuzzers earlier in the list (each of which\nwill also apply its own way to simplify the values).\n\nThere are a few circumstances in which this function will return an invalid\nfuzzer, which causes it to fail any test that uses it:\n\n  - If you provide an empty list of frequencies\n  - If any of the weights are less than 0\n  - If the weights sum to 0\n\nBe careful recursively using this fuzzer in its arguments. Often using\n[`Fuzz.map`](#map) is a better way to do what you want. If you are fuzzing a\ntree-like data structure, you should include a depth limit so to avoid infinite\nrecursion, like so:\n\n    type Tree\n        = Leaf\n        | Branch Tree Tree\n\n    tree : Int -> Fuzzer Tree\n    tree i =\n        if i <= 0 then\n            Fuzz.constant Leaf\n\n        else\n            Fuzz.frequency\n                [ ( 1, Fuzz.constant Leaf )\n                , ( 2, Fuzz.map2 Branch (tree (i - 1)) (tree (i - 1)) )\n                ]\n\n","type":"List.List ( Basics.Float, Fuzz.Fuzzer a ) -> Fuzz.Fuzzer a"},{"name":"frequencyValues","comment":" Create a `Fuzzer` by providing a list of probabilistic weights to use with\nvalues.\nFor example, to create a `Fuzzer` that has a 1/4 chance of generating a string\n\"foo\", and a 3/4 chance of generating a string \"bar\", you could do this:\n\n    Fuzz.frequencyValues\n        [ ( 1, \"foo\" )\n        , ( 3, \"bar\" )\n        ]\n\nThis fuzzer will simplify towards the values earlier in the list.\n\nThere are a few circumstances in which this function will return an invalid\nfuzzer, which causes it to fail any test that uses it:\n\n  - If you provide an empty list of frequencies\n  - If any of the weights are less than 0\n  - If the weights sum to 0\n\n","type":"List.List ( Basics.Float, a ) -> Fuzz.Fuzzer a"},{"name":"fromGenerator","comment":" (Avoid this function if you can! It is only provided as an escape hatch.)\n\nConvert a Random.Generator into a Fuzzer.\n\nWorks internally by generating a random seed and running `Random.step`.\n\nNote this will not shrink well (in fact it will shrink randomly, to smaller\n_seeds_), as Generators are black boxes from the perspective of Fuzzers. If you\nwant meaningful shrinking, define fuzzers using the other functions in this\nmodule!\n\n","type":"Random.Generator a -> Fuzz.Fuzzer a"},{"name":"int","comment":" A fuzzer for int values. It will never produce `NaN`, `Infinity`, or\n`-Infinity`.\n\nThis fuzzer will generate values in the range `Random.minInt .. Random.maxInt`.\n\n  - Simplifies towards 0\n  - Prefers positive values over negative ones\n  - Prefers smaller values over larger ones\n\n","type":"Fuzz.Fuzzer Basics.Int"},{"name":"intAtLeast","comment":" A fuzzer that will generate values in range n..2^32-1.\n","type":"Basics.Int -> Fuzz.Fuzzer Basics.Int"},{"name":"intAtMost","comment":" A fuzzer that will generate values in range -(2^32-1)..n.\n","type":"Basics.Int -> Fuzz.Fuzzer Basics.Int"},{"name":"intRange","comment":" A fuzzer for int values between a given minimum and maximum value,\ninclusive. Shrunk values will also be within the range.\n","type":"Basics.Int -> Basics.Int -> Fuzz.Fuzzer Basics.Int"},{"name":"invalid","comment":" A fuzzer that is invalid for the provided reason. Any fuzzers built with it\nare also invalid. Any tests using an invalid fuzzer fail.\n","type":"String.String -> Fuzz.Fuzzer a"},{"name":"labelExamples","comment":" Show examples of values satisfying given classification predicates (see\nalso [`Test.reportDistribution`](Test#reportDistribution) and\n[`Test.expectDistribution`](Test#expectDistribution)).\n\nGenerates a given number of values and classifies them based on the predicates.\n\nUses the first argument as the seed as well as the count of examples to\ngenerate.\n\nThis function will always return all the given \"base\" labels, even if no\nexamples of them could be found:\n\n    Fuzz.labelExamples 100\n        [ ( \"Lower boundary (1)\", \\n -> n == 1 )\n        , ( \"Upper boundary (20)\", \\n -> n == 20 )\n        , ( \"In the middle (2..19)\", \\n -> n > 1 && n < 20 )\n        , ( \"Outside boundaries??\", \\n -> n < 1 || n > 20 )\n        ]\n        (Fuzz.intRange 1 20)\n\n    -->\n    [ ( [ \"Lower boundary (1)\" ], Just 1 )\n    , ( [ \"Upper boundary (20)\" ], Just 20 )\n    , ( [ \"In the middle (2..19)\" ], Just 5 )\n    , ( [ \"Outside boundaries??\" ], Nothing )\n    ]\n\nIn case of predicate overlap (eg. something is both green and big) this\nfunction will also return all the found combinations:\n\n    Fuzz.labelExamples 100\n        [ ( \"fizz\", \\n -> (n |> modBy 3) == 0 )\n        , ( \"buzz\", \\n -> (n |> modBy 5) == 0 )\n        ]\n        (Fuzz.intRange 1 20)\n\n    -->\n    [ ( [ \"fizz\" ], Just 3 )\n    , ( [ \"buzz\" ], Just 10 )\n    , ( [ \"fizz, buzz\" ], Just 15 )\n    ]\n\n","type":"Basics.Int -> List.List ( String.String, a -> Basics.Bool ) -> Fuzz.Fuzzer a -> List.List ( List.List String.String, Maybe.Maybe a )"},{"name":"lazy","comment":" A fuzzer that delays its execution. Handy for recursive types and preventing\ninfinite recursion.\n","type":"(() -> Fuzz.Fuzzer a) -> Fuzz.Fuzzer a"},{"name":"list","comment":" Given a fuzzer of a type, create a fuzzer of a list of that type.\nGenerates random lists of varying length, up to 32 elements.\n","type":"Fuzz.Fuzzer a -> Fuzz.Fuzzer (List.List a)"},{"name":"listOfLength","comment":" Given a fuzzer of a type, create a fuzzer of a list of that type.\nGenerates random lists of exactly the specified length.\n","type":"Basics.Int -> Fuzz.Fuzzer a -> Fuzz.Fuzzer (List.List a)"},{"name":"listOfLengthBetween","comment":" Given a fuzzer of a type, create a fuzzer of a list of that type.\nGenerates random lists of length between the two given integers.\n","type":"Basics.Int -> Basics.Int -> Fuzz.Fuzzer a -> Fuzz.Fuzzer (List.List a)"},{"name":"map","comment":" Map a function over a fuzzer.\n","type":"(a -> b) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b"},{"name":"map2","comment":" Map over two fuzzers.\n","type":"(a -> b -> c) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c"},{"name":"map3","comment":" Map over three fuzzers.\n","type":"(a -> b -> c -> d) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c -> Fuzz.Fuzzer d"},{"name":"map4","comment":" Map over four fuzzers.\n","type":"(a -> b -> c -> d -> e) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c -> Fuzz.Fuzzer d -> Fuzz.Fuzzer e"},{"name":"map5","comment":" Map over five fuzzers.\n","type":"(a -> b -> c -> d -> e -> f) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c -> Fuzz.Fuzzer d -> Fuzz.Fuzzer e -> Fuzz.Fuzzer f"},{"name":"map6","comment":" Map over six fuzzers.\n","type":"(a -> b -> c -> d -> e -> f -> g) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c -> Fuzz.Fuzzer d -> Fuzz.Fuzzer e -> Fuzz.Fuzzer f -> Fuzz.Fuzzer g"},{"name":"map7","comment":" Map over seven fuzzers.\n","type":"(a -> b -> c -> d -> e -> f -> g -> h) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c -> Fuzz.Fuzzer d -> Fuzz.Fuzzer e -> Fuzz.Fuzzer f -> Fuzz.Fuzzer g -> Fuzz.Fuzzer h"},{"name":"map8","comment":" Map over eight fuzzers.\n","type":"(a -> b -> c -> d -> e -> f -> g -> h -> i) -> Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c -> Fuzz.Fuzzer d -> Fuzz.Fuzzer e -> Fuzz.Fuzzer f -> Fuzz.Fuzzer g -> Fuzz.Fuzzer h -> Fuzz.Fuzzer i"},{"name":"maybe","comment":" Given a fuzzer of a type, create a fuzzer of a maybe for that type.\n","type":"Fuzz.Fuzzer a -> Fuzz.Fuzzer (Maybe.Maybe a)"},{"name":"niceFloat","comment":" A fuzzer for float values.\n\nWill prefer integer values, nice fractions and positive numbers over the rest.\n\nWill never try infinities or NaN.\n\n","type":"Fuzz.Fuzzer Basics.Float"},{"name":"oneOf","comment":" Choose one of the given fuzzers at random. Each fuzzer has an equal chance\nof being chosen; to customize the probabilities, use [`Fuzz.frequency`](#frequency).\n\nThis fuzzer will simplify towards the fuzzers earlier in the list (each of which\nwill also apply its own way to simplify the values).\n\n    Fuzz.oneOf\n        [ Fuzz.intRange 0 3\n        , Fuzz.intRange 7 9\n        ]\n\n","type":"List.List (Fuzz.Fuzzer a) -> Fuzz.Fuzzer a"},{"name":"oneOfValues","comment":" Choose one of the given values at random. Each value has an equal chance\nof being chosen; to customize the probabilities, use\n[`Fuzz.frequencyValues`](#frequencyValues).\n\nThis fuzzer will simplify towards the values earlier in the list.\n\n    Fuzz.oneOfValues\n        [ 999\n        , -42\n        ]\n\n","type":"List.List a -> Fuzz.Fuzzer a"},{"name":"order","comment":" A fuzzer for order values.\n\nSimplifies in order `LT < EQ < GT`.\n\n","type":"Fuzz.Fuzzer Basics.Order"},{"name":"pair","comment":" Create a fuzzer of pairs from two fuzzers.\n","type":"Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer ( a, b )"},{"name":"percentage","comment":" A fuzzer for percentage values. Generates random floats between `0.0`\ninclusive and `1.0` exclusive, in an uniform fashion.\n\nWill occasionally try the boundaries.\n\nDoesn't shrink to nice values like [`Fuzz.float`](#float) does; shrinks towards\nzero.\n\n","type":"Fuzz.Fuzzer Basics.Float"},{"name":"result","comment":" Given fuzzers for an error type and a success type, create a fuzzer for\na result.\n","type":"Fuzz.Fuzzer error -> Fuzz.Fuzzer value -> Fuzz.Fuzzer (Result.Result error value)"},{"name":"sequence","comment":" Executes every fuzzer in the list and collects their values into the returned\nlist.\n\nRejections (eg. from [`Fuzz.filter`](#filter) or [`Fuzz.invalid`](#invalid))\nbubble up instead of being discarded.\n\n","type":"List.List (Fuzz.Fuzzer a) -> Fuzz.Fuzzer (List.List a)"},{"name":"shuffledList","comment":" A fuzzer that shuffles the given list.\n","type":"List.List a -> Fuzz.Fuzzer (List.List a)"},{"name":"string","comment":" Generates random unicode strings of up to 10 characters.\n","type":"Fuzz.Fuzzer String.String"},{"name":"stringOfLength","comment":" Generates random unicode strings of a given length.\n\nNote that some unicode characters have `String.length` of 2. This fuzzer will\nmake sure the `String.length` of the returned string is equal to the wanted\nlength, even if it will mean there are less characters. If you instead want it\nto give N characters even if their `String.length` will be above N, you can use\n\n    Fuzz.listOfLength n Fuzz.char\n        |> Fuzz.map String.fromList\n\n","type":"Basics.Int -> Fuzz.Fuzzer String.String"},{"name":"stringOfLengthBetween","comment":" Generates random unicode strings of length between the given limits.\n\nNote that some unicode characters have `String.length` of 2. This fuzzer will\nmake sure the `String.length` of the returned string is equal to the wanted\nlength, even if it will mean there are less characters. If you instead want it\nto give between MIN and MAX characters even if their `String.length` will be\nabove MAX, you can use\n\n    Fuzz.listOfLengthBetween min max Fuzz.char\n        |> Fuzz.map String.fromList\n\n","type":"Basics.Int -> Basics.Int -> Fuzz.Fuzzer String.String"},{"name":"traverse","comment":" Runs the Fuzzer-returning function on every item in the list, executes them=\nand collects their values into the returned list.\n\nRejections (eg. from [`Fuzz.filter`](#filter) or [`Fuzz.invalid`](#invalid))\nbubble up instead of being discarded.\n\n","type":"(a -> Fuzz.Fuzzer b) -> List.List a -> Fuzz.Fuzzer (List.List b)"},{"name":"triple","comment":" Create a fuzzer of triples from three fuzzers.\n","type":"Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c -> Fuzz.Fuzzer ( a, b, c )"},{"name":"uniformInt","comment":" Draw an integer between 0 and n inclusive.\n\nWill simplify towards 0, but draws uniformly over the whole range.\n\nMax supported value is 2^32 - 1.\n\n","type":"Basics.Int -> Fuzz.Fuzzer Basics.Int"},{"name":"unit","comment":" A fuzzer for the unit value. Unit is a type with only one value, commonly\nused as a placeholder.\n","type":"Fuzz.Fuzzer ()"},{"name":"weightedBool","comment":" A fuzzer for boolean values, generating True with the given probability\n(0.0 = always False, 1.0 = always True).\n\nProbabilities outside the `0..1` range will be clamped to `0..1`.\n\nSimplifies towards False (if not prevented to do that by using probability >= 1).\n\n","type":"Basics.Float -> Fuzz.Fuzzer Basics.Bool"}],"binops":[]},{"name":"Test","comment":" A module containing functions for creating and managing tests.\n\n@docs Test, test\n\n\n## Organizing Tests\n\n@docs describe, concat, todo, skip, only\n\n\n## Fuzz Testing\n\n@docs fuzz, fuzz2, fuzz3, fuzzWith, FuzzOptions\n@docs Distribution, noDistribution, reportDistribution, expectDistribution\n\n","unions":[],"aliases":[{"name":"Distribution","comment":" With `Distribution` you can observe statistics about your fuzz test inputs and\nassert that a given proportion of test cases belong to a given class.\n\n  - `noDistribution` opts out of these checks.\n\n  - `reportDistribution` will collect statistics and report them after the test\n    runs (both when it passes and fails) and so is mostly useful as a temporary\n    setting when creating your fuzzers and tests.\n\n  - `expectDistribution` will collect statistics, but only report them (and fail\n    the test) if the `ExpectedDistribution` is not met. Handy for checking your\n    fuzzers are giving interesting and relevant inputs to your tests.\n\n```elm\nfuzzWith { runs = 10000, distribution = noDistribution }\n\nfuzzWith\n    { runs = 10000\n    , distribution =\n        reportDistribution\n            [ ( \"fizz\", \\n -> (n |> modBy 3) == 0 )\n            , ( \"buzz\", \\n -> (n |> modBy 5) == 0 )\n            , ( \"even\", \\n -> (n |> modBy 2) == 0 )\n            , ( \"odd\", \\n -> (n |> modBy 2) == 1 )\n            ]\n    }\n\nfuzzWith\n    { runs = 10000\n    , distribution =\n        expectDistribution\n            [ ( Test.Distribution.atLeast 30, \"fizz\", \\n -> (n |> modBy 3) == 0 )\n            , ( Test.Distribution.atLeast 15, \"buzz\", \\n -> (n |> modBy 5) == 0 )\n            , ( Test.Distribution.moreThanZero, \"fizz buzz\", \\n -> (n |> modBy 15) == 0 )\n            , ( Test.Distribution.zero, \"outside range\", \\n -> n < 1 || n > 20 )\n            ]\n    }\n```\n\nThe `a` type variable in `Distribution a` is the same type as your fuzzed type.\n\nFor example, if you're fuzzing a String with `Fuzzer String` and want to see\ndistribution information for values produced by this fuzzer, you need to provide\n`String -> Bool` functions to your `reportDistribution` or `expectDistribution` calls,\nwhich will in turn produce a `Distribution String`.\n\n","args":["a"],"type":"Test.Distribution.Internal.Distribution a"},{"name":"FuzzOptions","comment":" Options [`fuzzWith`](#fuzzWith) accepts.\n\n\n### `runs`\n\nThe number of times to run each fuzz test. (Default is 100.)\n\n    import Test exposing (fuzzWith)\n    import Fuzz exposing (list, int)\n    import Expect\n\n    fuzzWith { runs = 350, distribution = noDistribution }\n        (list int)\n        \"List.length should never be negative\" <|\n        -- This anonymous function will be run 350 times, each time with a\n        -- randomly-generated fuzzList value. (It will always be a list of ints\n        -- because of (list int) above.)\n        \\fuzzList ->\n            fuzzList\n                |> List.length\n                |> Expect.atLeast 0\n\n\n### `distribution`\n\nA way to report/enforce a statistical distribution of your input values.\n(Default is `noDistribution`.)\n\n    import Test exposing (fuzzWith)\n    import Test.Distribution\n    import Fuzz exposing (list, int)\n    import Expect\n\n    fuzzWith\n        { runs = 350\n        , distribution =\n            expectDistribution\n                [ ( Test.Distribution.zero, \"empty\", \\xs -> List.length xs == 0 )\n                , ( Test.Distribution.atLeast 10, \"3+ items\", \\xs -> List.length xs >= 3 )\n                ]\n        }\n        (list int)\n        \"Sum > Average\"\n    <|\n        \\xs ->\n            List.sum xs\n                |> Expect.greaterThan (average xs)\n\n","args":["a"],"type":"{ runs : Basics.Int, distribution : Test.Distribution a }"},{"name":"Test","comment":" A test which has yet to be evaluated. When evaluated, it produces one\nor more [`Expectation`](../Expect#Expectation)s.\n\nSee [`test`](#test) and [`fuzz`](#fuzz) for some ways to create a `Test`.\n\n","args":[],"type":"Test.Internal.Test"}],"values":[{"name":"concat","comment":" Run each of the given tests.\n\n    concat [ testDecoder, testSorting ]\n\n","type":"List.List Test.Test -> Test.Test"},{"name":"describe","comment":" Apply a description to a list of tests.\n\n    import Test exposing (describe, test, fuzz)\n    import Fuzz exposing (int)\n    import Expect\n\n\n    describe \"List\"\n        [ describe \"reverse\"\n            [ test \"has no effect on an empty list\" <|\n                \\_ ->\n                    List.reverse []\n                        |> Expect.equal []\n            , fuzz int \"has no effect on a one-item list\" <|\n                \\num ->\n                     List.reverse [ num ]\n                        |> Expect.equal [ num ]\n            ]\n        ]\n\nPassing an empty list will result in a failing test, because you either made a\nmistake or are creating a placeholder.\n\n","type":"String.String -> List.List Test.Test -> Test.Test"},{"name":"expectDistribution","comment":" Collects statistics and makes sure the expected distribution is met.\n\nFails the test and reports the distribution if the expected distribution is not met.\n\nUses a statistical test to make sure the distribution doesn't pass or fail the\ndistribution by accident (a flaky test). Will run more tests than specified with the\n`runs` config option if needed.\n\nThis has the consequence of running more tests the closer your expected distribution\nis to the true distribution. You can thus minimize and speed up this\n\"making sure\" process by requesting slightly less % of your distribution than\nneeded.\n\nCurrently the statistical test is tuned to allow a false positive/negative in\n1 in every 10^9 tests.\n\n","type":"List.List ( Test.Distribution.ExpectedDistribution, String.String, a -> Basics.Bool ) -> Test.Distribution a"},{"name":"fuzz","comment":" Take a function that produces a test, and calls it several (usually 100) times, using a randomly-generated input\nfrom a [`Fuzzer`](http://package.elm-lang.org/packages/elm-explorations/test/latest/Fuzz) each time. This allows you to\ntest that a property that should always be true is indeed true under a wide variety of conditions. The function also\ntakes a string describing the test.\n\nThese are called \"[fuzz tests](https://en.wikipedia.org/wiki/Fuzz_testing)\" because of the randomness.\nYou may find them elsewhere called [property-based tests](http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html),\n[generative tests](http://www.pivotaltracker.com/community/tracker-blog/generative-testing), or\n[QuickCheck-style tests](https://en.wikipedia.org/wiki/QuickCheck).\n\n    import Test exposing (fuzz)\n    import Fuzz exposing (list, int)\n    import Expect\n\n\n    fuzz (list int) \"List.length should never be negative\" <|\n        -- This anonymous function will be run 100 times, each time with a\n        -- randomly-generated fuzzList value.\n        \\fuzzList ->\n            fuzzList\n                |> List.length\n                |> Expect.atLeast 0\n\n","type":"Fuzz.Fuzzer a -> String.String -> (a -> Expect.Expectation) -> Test.Test"},{"name":"fuzz2","comment":" Run a [fuzz test](#fuzz) using two random inputs.\n\nThis is a convenience function that lets you skip calling [`Fuzz.pair`](Fuzz#pair).\n\nSee [`fuzzWith`](#fuzzWith) for an example of writing this using tuples.\n\n    import Test exposing (fuzz2)\n    import Fuzz exposing (list, int)\n\n\n    fuzz2 (list int) int \"List.reverse never influences List.member\" <|\n        \\nums target ->\n            List.member target (List.reverse nums)\n                |> Expect.equal (List.member target nums)\n\n","type":"Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> String.String -> (a -> b -> Expect.Expectation) -> Test.Test"},{"name":"fuzz3","comment":" Run a [fuzz test](#fuzz) using three random inputs.\n\nThis is a convenience function that lets you skip calling [`Fuzz.triple`](Fuzz#triple).\n\n","type":"Fuzz.Fuzzer a -> Fuzz.Fuzzer b -> Fuzz.Fuzzer c -> String.String -> (a -> b -> c -> Expect.Expectation) -> Test.Test"},{"name":"fuzzWith","comment":" Run a [`fuzz`](#fuzz) test with the given [`FuzzOptions`](#FuzzOptions).\n\nNote that there is no `fuzzWith2`, but you can always pass more fuzz values in\nusing [`Fuzz.pair`](Fuzz#pair), [`Fuzz.triple`](Fuzz#triple),\nfor example like this:\n\n    import Test exposing (fuzzWith)\n    import Fuzz exposing (pair, list, int)\n    import Expect\n\n\n    fuzzWith { runs = 4200, distribution = noDistribution }\n        (pair (list int) int)\n        \"List.reverse never influences List.member\" <|\n            \\(nums, target) ->\n                List.member target (List.reverse nums)\n                    |> Expect.equal (List.member target nums)\n\n","type":"Test.FuzzOptions a -> Fuzz.Fuzzer a -> String.String -> (a -> Expect.Expectation) -> Test.Test"},{"name":"noDistribution","comment":" Opts out of the test input distribution checking.\n","type":"Test.Distribution a"},{"name":"only","comment":" Returns a [`Test`](#Test) that causes other tests to be skipped, and\nonly runs the given one.\n\nCalls to `only` aren't meant to be committed to version control. Instead, use\nthem when you want to focus on getting a particular subset of your tests to pass.\nIf you use `only`, your entire test suite will fail, even if\neach of the individual tests pass. This is to help avoid accidentally\ncommitting a `only` to version control.\n\nIf you you use `only` on multiple tests, only those tests will run. If you\nput a `only` inside another `only`, only the outermost `only`\nwill affect which tests gets run.\n\nSee also [`skip`](#skip). Note that `skip` takes precedence over `only`;\nif you use a `skip` inside an `only`, it will still get skipped, and if you use\nan `only` inside a `skip`, it will also get skipped.\n\n    describe \"List\"\n        [ only <|\n            describe \"reverse\"\n                [ test \"has no effect on an empty list\" <|\n                    \\_ ->\n                        List.reverse []\n                            |> Expect.equal []\n                , fuzz int \"has no effect on a one-item list\" <|\n                    \\num ->\n                        List.reverse [ num ]\n                            |> Expect.equal [ num ]\n                ]\n        , test \"This will not get run, because of the `only` above!\" <|\n            \\_ ->\n                List.length []\n                    |> Expect.equal 0\n        ]\n\n","type":"Test.Test -> Test.Test"},{"name":"reportDistribution","comment":" Collects statistics and reports them after the test runs (both when it passes\nand fails).\n","type":"List.List ( String.String, a -> Basics.Bool ) -> Test.Distribution a"},{"name":"skip","comment":" Returns a [`Test`](#Test) that gets skipped.\n\nCalls to `skip` aren't meant to be committed to version control. Instead, use\nit when you want to focus on getting a particular subset of your tests to\npass. If you use `skip`, your entire test suite will fail, even if\neach of the individual tests pass. This is to help avoid accidentally\ncommitting a `skip` to version control.\n\nSee also [`only`](#only). Note that `skip` takes precedence over `only`;\nif you use a `skip` inside an `only`, it will still get skipped, and if you use\nan `only` inside a `skip`, it will also get skipped.\n\n    describe \"List\"\n        [ skip <|\n            describe \"reverse\"\n                [ test \"has no effect on an empty list\" <|\n                    \\_ ->\n                        List.reverse []\n                            |> Expect.equal []\n                , fuzz int \"has no effect on a one-item list\" <|\n                    \\num ->\n                        List.reverse [ num ]\n                            |> Expect.equal [ num ]\n                ]\n        , test \"This is the only test that will get run; the other was skipped!\" <|\n            \\_ ->\n                List.length []\n                    |> Expect.equal 0\n        ]\n\n","type":"Test.Test -> Test.Test"},{"name":"test","comment":" Return a [`Test`](#Test) that evaluates a single\n[`Expectation`](../Expect#Expectation).\n\n    import Test exposing (fuzz)\n    import Expect\n\n\n    test \"the empty list has 0 length\" <|\n        \\_ ->\n            List.length []\n                |> Expect.equal 0\n\n","type":"String.String -> (() -> Expect.Expectation) -> Test.Test"},{"name":"todo","comment":" Returns a [`Test`](#Test) that is \"TODO\" (not yet implemented). These tests\nalways fail, but test runners will only include them in their output if there\nare no other failures.\n\nThese tests aren't meant to be committed to version control. Instead, use them\nwhen you're brainstorming lots of tests you'd like to write, but you can't\nimplement them all at once. When you replace `todo` with a real test, you'll be\nable to see if it fails without clutter from tests still not implemented. But,\nunlike leaving yourself comments, you'll be prompted to implement these tests\nbecause your suite will fail.\n\n    describe \"a new thing\"\n        [ todo \"does what is expected in the common case\"\n        , todo \"correctly handles an edge case I just thought of\"\n        ]\n\nThis functionality is similar to \"pending\" tests in other frameworks, except\nthat a TODO test is considered failing but a pending test often is not.\n\n","type":"String.String -> Test.Test"}],"binops":[]},{"name":"Test.Distribution","comment":"\n\n\n## Distribution\n\n@docs ExpectedDistribution, atLeast, zero, moreThanZero\n@docs DistributionReport, distributionReportTable\n\n","unions":[{"name":"DistributionReport","comment":" A result of a distribution check.\n\nGet it from your `Expectation` with `Test.Runner.getDistributionReport`.\n\n","args":[],"cases":[["NoDistribution",[]],["DistributionToReport",["{ distributionCount : Dict.Dict (List.List String.String) Basics.Int, runsElapsed : Basics.Int }"]],["DistributionCheckSucceeded",["{ distributionCount : Dict.Dict (List.List String.String) Basics.Int, runsElapsed : Basics.Int }"]],["DistributionCheckFailed",["{ distributionCount : Dict.Dict (List.List String.String) Basics.Int, runsElapsed : Basics.Int, badLabel : String.String, badLabelPercentage : Basics.Float, expectedDistribution : String.String }"]]]}],"aliases":[{"name":"ExpectedDistribution","comment":" Your input distribution requirement for the fuzzer used in a test.\n\nFor example, \"this test shouldn't ever receive strings of length < 3 as an input\"\nor \"at least 30% of the test input trees should be balanced\".\n\n","args":[],"type":"Test.Distribution.Internal.ExpectedDistribution"}],"values":[{"name":"atLeast","comment":" A requirement that a given value class should happen at least N% of the time\nin a given test.\n\nThe example below says that at least 30% of the fuzz test inputs should be\nmultiples of 3.\n\n    fuzzWith\n        { runs = 10000\n        , distribution =\n            expectDistribution\n                [ ( atLeast 30, \"multiple of 3\", \\n -> (n |> modBy 3) == 0 )\n                ]\n        }\n\n","type":"Basics.Float -> Test.Distribution.ExpectedDistribution"},{"name":"distributionReportTable","comment":" Prettyprints the record inside `DistributionReport` into a table with histograms.\n","type":"{ a | runsElapsed : Basics.Int, distributionCount : Dict.Dict (List.List String.String) Basics.Int } -> String.String"},{"name":"moreThanZero","comment":" A requirement that a given value class should happen at least once in a given\ntest.\n","type":"Test.Distribution.ExpectedDistribution"},{"name":"zero","comment":" A requirement that a given value class should never happen in a given test.\n","type":"Test.Distribution.ExpectedDistribution"}],"binops":[]},{"name":"Test.Html.Event","comment":" This module lets you simulate events on `Html` values and expect that\nthey result in certain `Msg` values being sent to `update`.\n\n\n## Simulating Events\n\n@docs Event, simulate, expect, toResult\n\n\n## Testing Event Effects\n\nThese functions allow you to test that your event handlers are (or are not) calling\n[`stopPropagation()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation)\nand\n[`preventDefault()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault).\nIn Elm, you do this by calling\n[special functions](https://package.elm-lang.org/packages/elm/html/latest/Html-Events#stopPropagationOn)\nin `Html.Events`.\n\n@docs expectStopPropagation, expectNotStopPropagation, expectPreventDefault, expectNotPreventDefault\n\n\n## Event Builders\n\n@docs custom, click, doubleClick, mouseDown, mouseUp, mouseEnter, mouseLeave, mouseOver, mouseOut, input, check, submit, blur, focus\n\n","unions":[{"name":"Event","comment":" A simulated event.\n\nSee [`simulate`](#simulate).\n\n","args":["msg"],"cases":[]}],"aliases":[],"values":[{"name":"blur","comment":" A [`blur`](https://developer.mozilla.org/en-US/docs/Web/Events/blur) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"check","comment":" A [`change`](https://developer.mozilla.org/en-US/docs/Web/Events/change) event\nwhere `event.target.checked` is set to the given `Bool` value.\n","type":"Basics.Bool -> ( String.String, Json.Encode.Value )"},{"name":"click","comment":" A [`click`](https://developer.mozilla.org/en-US/docs/Web/Events/click) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"custom","comment":" Simulate a custom event. The `String` is the event name, and the `Value` is the event object\nthe browser would send to the event listener callback.\n\n    import Test.Html.Event as Event\n    import Json.Encode as Encode exposing (Value)\n\n\n    type Msg\n        = Change String\n\n\n    test \"Input produces expected Msg\" <|\n        \\() ->\n            let\n                simulatedEventObject : Value\n                simulatedEventObject =\n                    Encode.object\n                        [ ( \"target\"\n                          , Encode.object [ ( \"value\", Encode.string \"cats\" ) ]\n                          )\n                        ]\n            in\n                Html.input [ onInput Change ] [ ]\n                    |> Query.fromHtml\n                    |> Event.simulate (Event.custom \"input\" simulatedEventObject)\n                    |> Event.expect (Change \"cats\")\n\n","type":"String.String -> Json.Encode.Value -> ( String.String, Json.Encode.Value )"},{"name":"doubleClick","comment":" A [`dblclick`](https://developer.mozilla.org/en-US/docs/Web/Events/dblclick) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"expect","comment":" Passes if the given message is triggered by the simulated event.\n\n    import Test.Html.Event as Event\n\n    type Msg\n        = Change String\n\n\n    test \"Input produces expected Msg\" <|\n        \\() ->\n            Html.input [ onInput Change ] [ ]\n                |> Query.fromHtml\n                |> Event.simulate (Event.input \"cats\")\n                |> Event.expect (Change \"cats\")\n\n","type":"msg -> Test.Html.Event.Event msg -> Expect.Expectation"},{"name":"expectNotPreventDefault","comment":" Passes if the event handler doesn't prevent default action of the event.\n","type":"Test.Html.Event.Event msg -> Expect.Expectation"},{"name":"expectNotStopPropagation","comment":" Passes if the event handler doesn't stop propagation of the event.\n","type":"Test.Html.Event.Event msg -> Expect.Expectation"},{"name":"expectPreventDefault","comment":" Passes if the event handler prevents default action of the event.\n","type":"Test.Html.Event.Event msg -> Expect.Expectation"},{"name":"expectStopPropagation","comment":" Passes if the event handler stops propagation of the event.\n","type":"Test.Html.Event.Event msg -> Expect.Expectation"},{"name":"focus","comment":" A [`focus`](https://developer.mozilla.org/en-US/docs/Web/Events/focus) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"input","comment":" An [`input`](https://developer.mozilla.org/en-US/docs/Web/Events/input) event.\n","type":"String.String -> ( String.String, Json.Encode.Value )"},{"name":"mouseDown","comment":" A [`mousedown`](https://developer.mozilla.org/en-US/docs/Web/Events/mousedown) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"mouseEnter","comment":" A [`mouseenter`](https://developer.mozilla.org/en-US/docs/Web/Events/mouseenter) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"mouseLeave","comment":" A [`mouseleave`](https://developer.mozilla.org/en-US/docs/Web/Events/mouseleave) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"mouseOut","comment":" A [`mouseout`](https://developer.mozilla.org/en-US/docs/Web/Events/mouseout) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"mouseOver","comment":" A [`mouseover`](https://developer.mozilla.org/en-US/docs/Web/Events/mouseover) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"mouseUp","comment":" A [`mouseup`](https://developer.mozilla.org/en-US/docs/Web/Events/mouseup) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"simulate","comment":" Simulate an event on a node.\n\n    import Test.Html.Event as Event\n\n    type Msg\n        = Change String\n\n\n    test \"Input produces expected Msg\" <|\n        \\() ->\n            Html.input [ onInput Change ] [ ]\n                |> Query.fromHtml\n                |> Event.simulate (Event.input \"cats\")\n                |> Event.expect (Change \"cats\")\n\n","type":"( String.String, Json.Encode.Value ) -> Test.Html.Query.Single msg -> Test.Html.Event.Event msg"},{"name":"submit","comment":" A [`submit`](https://developer.mozilla.org/en-US/docs/Web/Events/submit) event.\n","type":"( String.String, Json.Encode.Value )"},{"name":"toResult","comment":" Returns a Result with the Msg produced by the event simulated on a node.\nNote that Event.expect gives nicer messages; this is generally more useful\nwhen testing that an event handler is _not_ present.\n\n    import Test.Html.Event as Event\n\n\n    test \"Input produces expected Msg\" <|\n        \\() ->\n            Html.input [ onInput Change ] [ ]\n                |> Query.fromHtml\n                |> Event.simulate (Event.input \"cats\")\n                |> Event.toResult\n                |> Expect.equal (Ok (Change \"cats\"))\n\n","type":"Test.Html.Event.Event msg -> Result.Result String.String msg"}],"binops":[]},{"name":"Test.Html.Query","comment":" Querying HTML structure.\n\n@docs Single, Multiple, fromHtml\n\n\n## Querying\n\n@docs find, findAll, children, first, index, keep\n\n\n## Expecting\n\n@docs count, contains, has, hasNot, each\n\n","unions":[],"aliases":[{"name":"Multiple","comment":" A query that may find any number of elements, including zero.\n\nContrast with [`Single`](#Single).\n\n","args":["msg"],"type":"Test.Html.Query.Internal.Multiple msg"},{"name":"Single","comment":" A query that expects to find exactly one element.\n\nContrast with [`Multiple`](#Multiple).\n\n","args":["msg"],"type":"Test.Html.Query.Internal.Single msg"}],"values":[{"name":"children","comment":" Return the matched element's immediate child elements.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, classes)\n\n\n    test \"The <ul> only has <li> children\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [ class \"item\"] [ text \"first item\" ]\n                    , li [ class \"item selected\"] [ text \"second item\" ]\n                    , li [ class \"item\"] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.find [ class \"items\" ]\n                |> Query.children [ class \"selected\" ]\n                |> Query.count (Expect.equal 1)\n\n","type":"List.List Test.Html.Selector.Selector -> Test.Html.Query.Single msg -> Test.Html.Query.Multiple msg"},{"name":"contains","comment":" Expect the element to have at least one descendant matching each node in the list.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, classes)\n\n\n    test \"The list has two li: one with the text \\\"third item\\\" and \\\n        another one with \\\"first item\\\"\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ text \"first item\" ]\n                    , li [] [ text \"second item\" ]\n                    , li [] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.contains\n                    [ li [] [ text \"third item\" ]\n                    , li [] [ text \"first item\" ]\n                    ]\n\n","type":"List.List (Html.Html msg) -> Test.Html.Query.Single msg -> Expect.Expectation"},{"name":"count","comment":" Expect the number of elements matching the query fits the given expectation.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag)\n    import Expect\n\n\n    test \"The list has three items\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ text \"first item\" ]\n                    , li [] [ text \"second item\" ]\n                    , li [] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.findAll [ tag \"li\" ]\n                |> Query.count (Expect.equal 3)\n\n","type":"(Basics.Int -> Expect.Expectation) -> Test.Html.Query.Multiple msg -> Expect.Expectation"},{"name":"each","comment":" Expect that a [`Single`](#Single) expectation will hold true for each of the\n[`Multiple`](#Multiple) matched elements.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, classes)\n\n\n    test \"The list has both the classes 'items' and 'active'\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ text \"first item\" ]\n                    , li [] [ text \"second item\" ]\n                    , li [] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.findAll [ tag \"ul\" ]\n                |> Query.each\n                    (Expect.all\n                        [ Query.has [ tag \"ul\" ]\n                        , Query.has [ classes [ \"items\", \"active\" ] ]\n                        ]\n                    )\n\n","type":"(Test.Html.Query.Single msg -> Expect.Expectation) -> Test.Html.Query.Multiple msg -> Expect.Expectation"},{"name":"find","comment":" Find exactly one descendant element which matches all the given selectors.\nIf no descendants match, or if more than one matches, the test will fail.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, classes)\n\n\n    test \"The list has both the classes 'items' and 'active'\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ text \"first item\" ]\n                    , li [] [ text \"second item\" ]\n                    , li [] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.find [ tag \"ul\" ]\n                |> Query.has [ classes [ \"items\", \"active\" ] ]\n\n","type":"List.List Test.Html.Selector.Selector -> Test.Html.Query.Single msg -> Test.Html.Query.Single msg"},{"name":"findAll","comment":" Find the descendant elements which match all the given selectors.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag)\n    import Expect\n\n\n    test \"The list has three items\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ text \"first item\" ]\n                    , li [] [ text \"second item\" ]\n                    , li [] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.findAll [ tag \"li\" ]\n                |> Query.count (Expect.equal 3)\n\n","type":"List.List Test.Html.Selector.Selector -> Test.Html.Query.Single msg -> Test.Html.Query.Multiple msg"},{"name":"first","comment":" Return the first element in a match. If there were no matches, the test\nwill fail.\n\n`Query.first` is a shorthand for `Query.index 0` - they do the same thing.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, classes)\n\n\n    test \"The first <li> is called 'first item'\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ text \"first item\" ]\n                    , li [] [ text \"second item\" ]\n                    , li [] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.findAll [ tag \"li\" ]\n                |> Query.first\n                |> Query.has [ text \"first item\" ]\n\n","type":"Test.Html.Query.Multiple msg -> Test.Html.Query.Single msg"},{"name":"fromHtml","comment":" Translate a `Html` value into a `Single` query. This is how queries\ntypically begin.\n\n    import Html\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (text)\n\n\n    test \"Button has the expected text\" <|\n        \\() ->\n            Html.button [] [ Html.text \"I'm a button!\" ]\n                |> Query.fromHtml\n                |> Query.has [ text \"I'm a button!\" ]\n\n","type":"Html.Html msg -> Test.Html.Query.Single msg"},{"name":"has","comment":" Expect the element to match all of the given selectors.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, classes)\n\n\n    test \"The list has both the classes 'items' and 'active'\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ text \"first item\" ]\n                    , li [] [ text \"second item\" ]\n                    , li [] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.find [ tag \"ul\" ]\n                |> Query.has [ tag \"ul\", classes [ \"items\", \"active\" ] ]\n\n","type":"List.List Test.Html.Selector.Selector -> Test.Html.Query.Single msg -> Expect.Expectation"},{"name":"hasNot","comment":" Expect the element to **not** match all of the given selectors.\n\n    import Html exposing (div)\n    import Html.Attributes as Attributes\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, class)\n\n\n    test \"The div element has no progress-bar class\" <|\n        \\() ->\n            div [ Attributes.class \"button\" ] []\n                |> Query.fromHtml\n                |> Query.find [ tag \"div\" ]\n                |> Query.hasNot [ tag \"div\", class \"progress-bar\" ]\n\n","type":"List.List Test.Html.Selector.Selector -> Test.Html.Query.Single msg -> Expect.Expectation"},{"name":"index","comment":" Return the element in a match at the given index. For example,\n`Query.index 0` would match the first element, and `Query.index 1` would match\nthe second element.\n\nYou can pass negative numbers to get elements from the end - for example, `Query.index -1`\nwill match the last element, and `Query.index -2` will match the second-to-last.\n\nIf the index falls outside the bounds of the match, the test will fail.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, classes)\n\n\n    test \"The second <li> is called 'second item'\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ text \"first item\" ]\n                    , li [] [ text \"second item\" ]\n                    , li [] [ text \"third item\" ]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.findAll [ tag \"li\" ]\n                |> Query.index 1\n                |> Query.has [ text \"second item\" ]\n\n","type":"Basics.Int -> Test.Html.Query.Multiple msg -> Test.Html.Query.Single msg"},{"name":"keep","comment":" Find the descendant elements of the result of `findAll` which match all the given selectors.\n\n    import Html exposing (div, ul, li)\n    import Html.Attributes exposing (class)\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag)\n    import Expect\n\n\n    test \"The list has three items\" <|\n        \\() ->\n            div []\n                [ ul [ class \"items active\" ]\n                    [ li [] [ a [] [ text \"first item\" ]]\n                    , li [] [ a [] [ text \"second item\" ]]\n                    , li [] [ a [] [ text \"third item\" ]]\n                    , li [] [ button [] [ text \"button\" ]]\n                    ]\n                ]\n                |> Query.fromHtml\n                |> Query.findAll [ tag \"li\" ]\n                |> Query.keep ( tag \"a\" )\n                |> Expect.all\n                    [ Query.each (Query.has [ tag \"a\" ])\n                    , Query.first >> Query.has [ text \"first item\" ]\n                    ]\n\n","type":"Test.Html.Selector.Selector -> Test.Html.Query.Multiple msg -> Test.Html.Query.Multiple msg"}],"binops":[]},{"name":"Test.Html.Selector","comment":" Selecting HTML elements.\n\n@docs Selector\n\n\n## General Selectors\n\n@docs tag, text, exactText, containing, attribute, all\n\n\n## Attributes\n\n@docs id, class, classes, exactClassName, style, checked, selected, disabled\n\n","unions":[],"aliases":[{"name":"Selector","comment":" A selector used to filter sets of elements.\n","args":[],"type":"Test.Html.Selector.Internal.Selector"}],"values":[{"name":"all","comment":" Combine the given selectors into one which requires all of them to match.\n\n    import Html\n    import Html.Attributes as Attr\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (class, text, all, Selector)\n\n\n    replyBtnSelector : Selector\n    replyBtnSelector =\n        all [ class \"btn\", text \"Reply\" ]\n\n\n    test \"Button has the class 'btn' and the text 'Reply'\" <|\n        \\() ->\n            Html.button [ Attr.class \"btn btn-large\" ] [ Html.text \"Reply\" ]\n                |> Query.fromHtml\n                |> Query.has [ replyBtnSelector ]\n\n","type":"List.List Test.Html.Selector.Selector -> Test.Html.Selector.Selector"},{"name":"attribute","comment":" Matches elements that have the given attribute in a way that makes sense\ngiven their semantics in `Html`.\n","type":"Html.Attribute Basics.Never -> Test.Html.Selector.Selector"},{"name":"checked","comment":" Matches elements that have a\n[`checked`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes#checked)\nattribute with the given value.\n","type":"Basics.Bool -> Test.Html.Selector.Selector"},{"name":"class","comment":" Matches elements that have the given class (and possibly others as well).\n\nTo match multiple classes at once, use [`classes`](#classes) instead.\n\nTo match the element's exact class attribute string, use [`exactClassName`](#exactClassName).\n\n    import Html\n    import Html.Attributes as Attr\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (class)\n\n\n    test \"Button has the class btn-large\" <|\n        \\() ->\n            Html.button [ Attr.class \"btn btn-large\" ] [ Html.text \"Reply\" ]\n                |> Query.fromHtml\n                |> Query.has [ class \"btn-large\" ]\n\n","type":"String.String -> Test.Html.Selector.Selector"},{"name":"classes","comment":" Matches elements that have all the given classes (and possibly others as well).\n\nWhen you only care about one class instead of several, you can use\n[`class`](#class) instead of passing this function a list with one value in it.\n\nTo match the element's exact class attribute string, use [`exactClassName`](#exactClassName).\n\n    import Html\n    import Html.Attributes as Attr\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (classes)\n\n\n    test \"Button has the classes btn and btn-large\" <|\n        \\() ->\n            Html.button [ Attr.class \"btn btn-large\" ] [ Html.text \"Reply\" ]\n                |> Query.fromHtml\n                |> Query.has [ classes [ \"btn\", \"btn-large\" ] ]\n\n","type":"List.List String.String -> Test.Html.Selector.Selector"},{"name":"containing","comment":" Matches elements whose descendants match the given selectors.\n\n(You will get the element and **not** the descendant.)\n\nThis is especially useful to find elements which contain specific\ntext somewhere in their descendants.\n\n    import Html\n    import Html.Events exposing (onClick)\n    import Test exposing (test)\n    import Test.Html.Event as Event\n    import Test.Html.Query as Query\n    import Test.Html.Selector exposing (containing, tag)\n\n    test : Test\n    test =\n        test \"...\" <|\n            Html.div []\n                [ Html.button [ onClick NopeMsg ] [ Html.text \"not me\" ]\n                , Html.button [ onClick ClickedMsg ] [ Html.text \"click me\" ]\n                ]\n                |> Query.fromHtml\n                |> Query.find\n                    [ tag \"button\"\n                    , containing [ text \"click me\" ]\n                    ]\n                |> Event.simulate Event.click\n                |> Event.expect ClickedMsg\n\n","type":"List.List Test.Html.Selector.Selector -> Test.Html.Selector.Selector"},{"name":"disabled","comment":" Matches elements that have a\n[`disabled`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes#disabled)\nattribute with the given value.\n","type":"Basics.Bool -> Test.Html.Selector.Selector"},{"name":"exactClassName","comment":" Matches the element's exact class attribute string.\n\nThis is used less often than [`class`](#class), [`classes`](#classes) or\n[`attribute`](#attribute), which check for the _presence_ of a class as opposed\nto matching the entire class attribute exactly.\n\n    import Html\n    import Html.Attributes as Attr\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (exactClassName)\n\n\n    test \"Button has the exact class 'btn btn-large'\" <|\n        \\() ->\n            Html.button [ Attr.class \"btn btn-large\" ] [ Html.text \"Reply\" ]\n                |> Query.fromHtml\n                |> Query.has [ exactClassName \"btn btn-large\" ]\n\n","type":"String.String -> Test.Html.Selector.Selector"},{"name":"exactText","comment":" Matches elements that have a\n[`text`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes#text)\nattribute with _exactly_ the given value (sans leading/trailing whitespace).\n\n`Selector.exactText \"11,22\"` will _not_ match `Html.text \"11,222\"`.\n\nNote this selector is whitespace sensitive (it _doesn't_ trim strings prior to\nchecking them):\n\n`Selector.exactText \"11,22\"` will _not_ match `Html.text \"\\n    11,22   \\n\"`.\n\nIf you need a partial match, take a look at [`text`](#text).\n\n","type":"String.String -> Test.Html.Selector.Selector"},{"name":"id","comment":" Matches elements that have the given `id` attribute.\n\n    import Html\n    import Html.Attributes as Attr\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (id, text)\n\n\n    test \"the welcome <h1> says hello!\" <|\n        \\() ->\n            Html.div []\n                [ Html.h1 [ Attr.id \"welcome\" ] [ Html.text \"Hello!\" ] ]\n                |> Query.fromHtml\n                |> Query.find [ id \"welcome\" ]\n                |> Query.has [ text \"Hello!\" ]\n\n","type":"String.String -> Test.Html.Selector.Selector"},{"name":"selected","comment":" Matches elements that have a\n[`selected`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes#selected)\nattribute with the given value.\n","type":"Basics.Bool -> Test.Html.Selector.Selector"},{"name":"style","comment":" Matches elements that have the given style properties (and possibly others as well).\n\n    import Html\n    import Html.Attributes as Attr\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (classes)\n\n\n    test \"the Reply button has red text\" <|\n        \\() ->\n            Html.div []\n                [ Html.button\n                    [ Attr.style \"color\" \"red\" ]\n                    [ Html.text \"Reply\" ]\n                ]\n                |> Query.has [ style \"color\" \"red\" ]\n\n","type":"String.String -> String.String -> Test.Html.Selector.Selector"},{"name":"tag","comment":" Matches elements that have the given tag.\n\n    import Html\n    import Html.Attributes as Attr\n    import Test.Html.Query as Query\n    import Test exposing (test)\n    import Test.Html.Selector exposing (tag, text)\n\n\n    test \"the welcome <h1> says hello!\" <|\n        \\() ->\n            Html.div []\n                [ Html.h1 [ Attr.id \"welcome\" ] [ Html.text \"Hello!\" ] ]\n                |> Query.fromHtml\n                |> Query.find [ tag \"h1\" ]\n                |> Query.has [ text \"Hello!\" ]\n\n","type":"String.String -> Test.Html.Selector.Selector"},{"name":"text","comment":" Matches elements that have a\n[`text`](http://package.elm-lang.org/packages/elm-lang/html/latest/Html-Attributes#text)\nattribute _containing_ the given value.\n\n`Selector.text \"11,22\"` will match `Html.text \"11,222\"`.\n\nIf you need an exact match, take a look at [`exactText`](#exactText).\n\n","type":"String.String -> Test.Html.Selector.Selector"}],"binops":[]},{"name":"Test.Runner","comment":" This is an \"experts only\" module that exposes functions needed to run and\ndisplay tests. A typical user will use an existing runner library for Node or\nthe browser, which is implemented using this interface. A list of these runners\ncan be found in the `README`.\n\n\n## Runner\n\n@docs Runner, SeededRunners, fromTest\n\n\n## Expectations\n\n@docs getFailureReason, isTodo\n\n\n## Distribution\n\n@docs getDistributionReport\n\n\n## Formatting\n\n@docs formatLabels\n\n\n## Fuzzers\n\nThese functions give you the ability to run fuzzers separate of running fuzz tests.\n\n@docs Simplifiable, fuzz, simplify\n\n","unions":[{"name":"SeededRunners","comment":" Test Runners which have had seeds distributed to them, and which are now\neither invalid or are ready to run. Seeded runners include some metadata:\n\n  - `Invalid` runners had a problem (e.g. two sibling tests had the same description) making them un-runnable.\n  - `Only` runners can be run, but `Test.only` was used somewhere, so ultimately they will lead to a failed test run even if each test that gets run passes.\n  - `Skipping` runners can be run, but `Test.skip` was used somewhere, so ultimately they will lead to a failed test run even if each test that gets run passes.\n  - `Plain` runners are ready to run, and have none of these issues.\n\n","args":[],"cases":[["Plain",["List.List Test.Runner.Runner"]],["Only",["List.List Test.Runner.Runner"]],["Skipping",["List.List Test.Runner.Runner"]],["Invalid",["String.String"]]]},{"name":"Simplifiable","comment":" A `Simplifiable a` is an opaque type that allows you to obtain a value of type\n`a` that is simpler than the one you've previously obtained.\n","args":["a"],"cases":[]}],"aliases":[{"name":"Runner","comment":" A function which, when evaluated, produces a list of expectations. Also a\nlist of labels which apply to this outcome.\n","args":[],"type":"{ run : () -> List.List Expect.Expectation, labels : List.List String.String }"}],"values":[{"name":"formatLabels","comment":" A standard way to format descriptions and test labels, to keep things\nconsistent across test runner implementations.\n\nThe HTML, Node, String, and Log runners all use this.\n\nWhat it does:\n\n  - drop any labels that are empty strings\n  - format the first label differently from the others\n  - reverse the resulting list\n\nExample:\n\n    [ \"the actual test that failed\"\n    , \"nested description failure\"\n    , \"top-level description failure\"\n    ]\n    |> formatLabels ((++) \"↓ \") ((++) \"✗ \")\n\n    {-\n    [ \"↓ top-level description failure\"\n    , \"↓ nested description failure\"\n    , \"✗ the actual test that failed\"\n    ]\n    -}\n\n","type":"(String.String -> format) -> (String.String -> format) -> List.List String.String -> List.List format"},{"name":"fromTest","comment":" Convert a `Test` into `SeededRunners`.\n\nIn order to run any fuzz tests that the `Test` may have, it requires a default run count as well\nas an initial `Random.Seed`. `100` is a good run count. To obtain a good random seed, pass a\nrandom 32-bit integer to `Random.initialSeed`. You can obtain such an integer by running\n`Math.floor(Math.random()*0xFFFFFFFF)` in Node. It's typically fine to hard-code this value into\nyour Elm code; it's easy and makes your tests reproducible.\n\n","type":"Basics.Int -> Random.Seed -> Test.Test -> Test.Runner.SeededRunners"},{"name":"fuzz","comment":" Given a fuzzer, return a random generator to produce a value and a\nSimplifiable. The value is what a fuzz test would have received as input.\n\nNote that fuzzers aren't generated to succeed, which is why this function returns\na Result. The String inside the Err case will contain a failure reason.\n\n","type":"Fuzz.Fuzzer a -> Random.Generator (Result.Result String.String ( a, Test.Runner.Simplifiable a ))"},{"name":"getDistributionReport","comment":" Returns a `DistributionReport` computed for a given test.\n","type":"Expect.Expectation -> Test.Distribution.DistributionReport"},{"name":"getFailureReason","comment":" Return `Nothing` if the given [`Expectation`](Expect#Expectation) is a [`pass`](Expect#pass).\n\nIf it is a [`fail`](Expect#fail), return a record containing the expectation\ndescription, the [`Reason`](Test-Runner-Failure#Reason) the test failed, and the given inputs if\nit was a fuzz test. (If it was not a fuzz test, the record's `given` field\nwill be `Nothing`).\n\nFor example:\n\n    getFailureReason (Expect.equal 1 2)\n    -- Just { reason = Equal 1 2, description = \"Expect.equal\", given = Nothing }\n\n    getFailureReason (Expect.equal 1 1)\n    -- Nothing\n\n","type":"Expect.Expectation -> Maybe.Maybe { given : Maybe.Maybe String.String, description : String.String, reason : Test.Runner.Failure.Reason }"},{"name":"isTodo","comment":" Determine if an expectation was created by a call to `Test.todo`. Runners\nmay treat these tests differently in their output.\n","type":"Expect.Expectation -> Basics.Bool"},{"name":"simplify","comment":" Given a Simplifiable, simplify the value further. Pass your test function to\ndrive the simplification process: if a simplified value passes the test, it will\nbe discarded. In this sense, you will get the simplest value that still fails\nyour test.\n","type":"(a -> Expect.Expectation) -> ( a, Test.Runner.Simplifiable a ) -> Maybe.Maybe ( a, Test.Runner.Simplifiable a )"}],"binops":[]},{"name":"Test.Runner.Failure","comment":" The reason a test failed.\n\n@docs Reason, InvalidReason\n\n","unions":[{"name":"InvalidReason","comment":" The reason a test run was invalid.\n\nTest runners should report these to the user in whatever format is appropriate.\n\n","args":[],"cases":[["EmptyList",[]],["NonpositiveFuzzCount",[]],["InvalidFuzzer",[]],["BadDescription",[]],["DuplicatedName",[]],["DistributionInsufficient",[]],["DistributionBug",[]]]},{"name":"Reason","comment":" The reason a test failed.\n\nTest runners can use this to provide nice output, e.g. by doing diffs on the\ntwo parts of an `Expect.equal` failure.\n\n","args":[],"cases":[["Custom",[]],["Equality",["String.String","String.String"]],["Comparison",["String.String","String.String"]],["ListDiff",["List.List String.String","List.List String.String"]],["CollectionDiff",["{ expected : String.String, actual : String.String, extra : List.List String.String, missing : List.List String.String }"]],["TODO",[]],["Invalid",["Test.Runner.Failure.InvalidReason"]]]}],"aliases":[],"values":[],"binops":[]}]